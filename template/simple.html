<p>There is an expectation from users that installed apps will always have a baseline experience if they&#39;re offline. That&#39;s why it&#39;s critical for installable web apps to never show Chrome&#39;s offline dinosaur game. The offline experience can range from a simple offline page, to a read-only experience with previously cached data, to a fully functional offline experience that automatically syncs when the network connection is restored.</p>
<p>In this section, we&#39;re going to add a simple offline page to our weather app. If the user tries to load the app while offline, it&#39;ll show our custom page, instead of the typical offline page that the browser shows. By the end of this section, our weather app will pass the following audits:</p>
<ul>
<li>Current page does not respond with a 200 when offline.</li>
<li><code>start_url</code> does not respond with a 200 when offline.</li>
<li>Does not register a service worker that controls page and <code>start_url.</code></li>
</ul>
<p>In the next section, we&#39;ll replace our custom offline page with a full offline experience. This will improve the offline experience, but more importantly, it&#39;ll significantly improve our performance, because most of our assets (HTML, CSS and JavaScript) will be stored and served locally, eliminating the network as a potential bottleneck.</p>
<h2 is-upgraded><strong>Service workers to the rescue</strong></h2>
<p>If you&#39;re unfamiliar with service workers, you can get a basic understanding of what they can do, how their lifecycle works, and more by reading <a href="https://developers.google.com/web/fundamentals/primers/service-worker/" target="_blank">Introduction To Service Workers</a>. </p>
<p>Features provided via service workers should be considered a progressive enhancement, and added only if supported by the browser. For example, with service workers you can cache the <a href="https://developers.google.com/web/fundamentals/architecture/app-shell" target="_blank">app shell</a> and data for your app, so that it&#39;s available even when the network isn&#39;t. When service workers aren&#39;t supported, the offline code isn&#39;t called, and the user gets a basic experience. Using feature detection to provide progressive enhancement has little overhead and it won&#39;t break in older browsers that don&#39;t support that feature.</p>
<aside class="warning"><p><strong>Remember:</strong> Service worker functionality is only available on pages that are accessed via HTTPS. (http://localhost and equivalents also work to facilitate testing.)</p>
</aside>
<h2 is-upgraded><strong>Register the service worker</strong></h2>
<p>The first step is to register the service worker. Add the following code to your <code>index.html</code> file:</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/index.html#L206" target="_blank">public/index.html</a></h3>
<pre><code>// CODELAB: Register service worker.
if (&#39;serviceWorker&#39; in navigator) {
  window.addEventListener(&#39;load&#39;, () =&gt; {
    navigator.serviceWorker.register(&#39;/service-worker.js&#39;)
        .then((reg) =&gt; {
          console.log(&#39;Service worker registered.&#39;, reg);
        });
  });
}</code></pre>
<p>This code checks to see if the service worker API is available, and if it is, the service worker at <code>/service-worker.js</code> is registered once the page is <a href="https://developers.google.com/web/fundamentals/primers/service-workers/registration" target="_blank">loaded</a>.</p>
<p>Note, the service worker is served from the root directory, not from a <code>/scripts/</code> directory. This is the easiest way to set the <strong><code>scope</code></strong> of your service worker. The <code>scope</code> of the service worker determines which files the service worker controls, in other words, from which path the service worker will intercept requests. The default <code>scope</code> is the location of the service worker file, and extends to all directories below. So if <code>service-worker.js</code> is located in the root directory, the service worker will control requests from all web pages at this domain.</p>
<h2 is-upgraded><strong>Precache offline page</strong></h2>
<p>First, we need to tell the service worker what to cache. We&#39;ve already created a simple <a href="https://your-first-pwa.glitch.me/offline.html" target="_blank">offline page</a> (<code>public/offline.html</code>) that we&#39;ll display any time there&#39;s no network connection.</p>
<p>In your <code>service-worker.js</code>, add <code>&#39;/offline.html&#39;,</code> to the <code>FILES_TO_CACHE</code> array, the final result should look like this:</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L23" target="_blank">public/service-worker.js</a></h3>
<pre><code>// CODELAB: Add list of files to cache here.
const FILES_TO_CACHE = [
  &#39;/offline.html&#39;,
];</code></pre>
<p>Next, we need to add the following code to the <code>install</code> event to tell the service worker to pre-cache the offline page:</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L29" target="_blank">public/service-worker.js</a></h3>
<pre><code>// CODELAB: Precache static resources here.
evt.waitUntil(
    caches.open(CACHE_NAME).then((cache) =&gt; {
      console.log(&#39;[ServiceWorker] Pre-caching offline page&#39;);
      return cache.addAll(FILES_TO_CACHE);
    })
);</code></pre>
<aside class="special"><p><strong>Note:</strong> Service worker events and life cycle is covered in the next section.</p>
</aside>
<p>Our <code>install</code> event now opens the cache with <code>caches.open()</code> and provides a cache name. Providing a cache name allows us to version files, or separate data from the cached resources so that we can easily update one but not affect the other.</p>
<p>Once the cache is open, we can then call <code>cache.addAll()</code>, which takes a list of URLs, fetches them from the server and adds the response to the cache. Note that <code>cache.addAll()</code> fails if any of the individual requests fail. That means you&#39;re guaranteed that, if the install step succeeds, your cache will be in a consistent state. But, if it fails for some reason, it will automatically try again the next time the service worker starts up.</p>
<h3 is-upgraded><strong>DevTools Detour</strong></h3>
<p>Let&#39;s take a look at how you can use DevTools to understand and debug service workers. Before reloading your page, open DevTools and go to the <strong>Service Workers</strong> pane on the <strong>Application</strong> panel. It should look like this:</p>
<p class="image-container"></p>
<p>When you see a blank page like this, it means that the currently open page does not have any registered service workers.</p>
<p>Now, reload your page. The Service Workers pane should now look like this:</p>
<p class="image-container"></p>
<p>When you see information like this, it means the page has a service worker running. </p>
<p>Next to the Status label, there&#39;s a number (<em>34251</em> in this case). Keep an eye on that number as you&#39;re working with service workers. It&#39;s an easy way to tell if your service worker has been updated.</p>
<h2 is-upgraded><strong>Clean-up old offline pages</strong></h2>
<p>We&#39;ll use the <code>activate</code> event to clean up any old data in our cache. This code ensures that your service worker updates its cache whenever any of the app shell files change. In order for this to work, you&#39;d need to increment the <code>CACHE_NAME</code> variable at the top of your service worker file.</p>
<p>Add the following code to your <code>activate</code> event:</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L36" target="_blank">public/service-worker.js</a></h3>
<pre><code>// CODELAB: Remove previous cached data from disk.
evt.waitUntil(
    caches.keys().then((keyList) =&gt; {
      return Promise.all(keyList.map((key) =&gt; {
        if (key !== CACHE_NAME) {
          console.log(&#39;[ServiceWorker] Removing old cache&#39;, key);
          return caches.delete(key);
        }
      }));
    })
);</code></pre>
<h3 is-upgraded><strong>DevTools Detour</strong></h3>
<p>With the Service Workers pane open, refresh the page. You&#39;ll see the new service worker installed and the status number incremented.</p>
<p class="image-container"></p>
<p>The updated service worker takes control immediately because our <code>install</code> event finishes with <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase" target="_blank"><code>self.skipWaiting()</code></a>, and the <code>activate</code> event finishes with <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#clientsclaim" target="_blank"><code>self.clients.claim()</code></a>. Without those, the old service worker would continue to control the page as long as there is a tab open to the page.</p>
<h2 is-upgraded><strong>Handle failed network requests</strong></h2>
<p>And finally, we need to handle <code>fetch</code> events. We&#39;re going to use a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache" target="_blank">Network falling back to cache </a>strategy. The service worker first tries to fetch the resource from the network. If that fails, the service worker returns the offline page from the cache.</p>
<p class="image-container"></p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L43" target="_blank">public/service-worker.js</a></h3>
<pre><code>// CODELAB: Add fetch event handler here.
if (evt.request.mode !== &#39;navigate&#39;) {
  // Not a page navigation, bail.
  return;
}
evt.respondWith(
    fetch(evt.request)
        .catch(() =&gt; {
          return caches.open(CACHE_NAME)
              .then((cache) =&gt; {
                return cache.match(&#39;offline.html&#39;);
              });
        })
);</code></pre>
<p>The <code>fetch</code> handler only needs to handle page navigations, so other requests can be dumped out of the handler and dealt with normally by the browser.  But, if the request <code>.mode</code> is <code>navigate</code>, use <code>fetch</code> to try to get the item from the network. If it fails, the <code>catch</code> handler opens the cache with <code>caches.open(CACHE_NAME)</code> and uses <code>cache.match(&#39;offline.html&#39;)</code> to get the precached offline page. The result is then passed back to the browser using <code>evt.respondWith()</code>. </p>
<aside class="special"><p>Wrapping the <code>fetch</code> call in <a href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith" target="_blank"><code>evt.respondWith()</code></a> prevents the browsers default fetch handling and tells the browser we want to handle the response ourselves. If you don&#39;t call <code>evt.respondWith()</code> inside of a <code>fetch</code> handler, you&#39;ll just get the default network behavior.</p>
</aside>
<h3 is-upgraded><strong>DevTools Detour</strong></h3>
<p>Let&#39;s check to make sure everything works as we expect it. With the <strong>Service Workers</strong> pane open, refresh the page. You&#39;ll see the new service worker installed and the status number incremented. </p>
<p>We can also check to see what&#39;s been cached. Go to the <strong>Cache Storage</strong> pane on the <strong>Application</strong> panel of DevTools. Right-click <strong>Cache Storage</strong>, pick <strong>Refresh Caches</strong>, and expand the section. You should see the name of your static cache listed on the left-hand side. Click on the cache name to see all of the files that are cached. </p>
<p class="image-container"></p>
<p>Now, let&#39;s test out offline mode. Go back to the <strong>Service Workers</strong> pane in the <strong>Application</strong> panel of DevTools and check the <strong>Offline</strong> checkbox. After checking it, you should see a little yellow warning icon next to the <strong>Network</strong> panel tab. This icon indicates that you&#39;re offline.</p>
<p class="image-container"></p>
<p>Reload your page and... it works! We get <strong>our</strong> offline panda, instead of Chrome&#39;s offline dino!</p>
<h2 is-upgraded><strong>Tips for testing service workers</strong></h2>
<p>Debugging service workers can be a challenge, and when it involves caching, things can become even more of a nightmare if the cache isn&#39;t updated when you expect it. Between the typical service worker lifecycle and a bug in your code, you may become quickly frustrated. <strong>But don&#39;t. </strong></p>
<h3 is-upgraded><strong>Use DevTools</strong></h3>
<p>In the <strong>Service Workers</strong> pane of the <strong>Application</strong> panel, there are a few checkboxes that will make your life much easier.</p>
<p class="image-container"></p>
<ul>
<li><strong>Offline</strong> - When checked, simulates an offline experience and prevents any requests from going to the network.</li>
<li><strong>Update on reload</strong> - When checked, will get the latest service worker, install it, and immediately activate it.</li>
<li><strong>Bypass for network</strong> - When checked, requests bypass the service worker and are sent directly to the network.</li>
</ul>
<h3 is-upgraded><strong>Start Fresh</strong></h3>
<p>In some cases, you may find yourself loading cached data or that things aren&#39;t updated as you expect. To clear all saved data (localStorage, indexedDB data, cached files) and remove any service workers, use the <strong>Clear storage</strong> pane in the <strong>Application</strong> panel. Alternatively, you can also work in an Incognito window.</p>
<p class="image-container"></p>
<p>Additional tips:</p>
<ul>
<li>Once a service worker has been unregistered, it may remain listed until its containing browser window is closed.</li>
<li>If multiple windows to your app are open, a new service worker will not take effect until all windows have been reloaded and updated to the latest service worker.</li>
<li>Unregistering a service worker does not clear the cache!</li>
<li>If a service worker exists and a new service worker is registered, the new service worker won&#39;t take control until the page is reloaded, unless you <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#clientsclaim" target="_blank">take immediate control</a>.</li>
</ul>
<h2 is-upgraded><strong>Verify changes with Lighthouse</strong></h2>
<p>Run Lighthouse again and verify your changes. Don&#39;t forget to uncheck the Offline checkbox before you verify your changes!</p>
<p><strong>SEO Audit</strong></p>
<ul>
<li><strong>✅ PASSED:</strong> Document has a meta description.</li>
</ul>
<p><strong>Progressive Web App Audit</strong></p>
<ul>
<li><strong>✅ PASSED:</strong> Current page responds with a 200 when offline.</li>
<li><strong>✅ PASSED: </strong><code>start_url</code> responds with a 200 when offline.</li>
<li><strong>✅ PASSED:</strong> Registers a service worker that controls page and <code>start_url.</code></li>
<li><strong>✅ PASSED:</strong> Web app manifest meets the installability requirements.</li>
<li><strong>✅ PASSED:</strong> Configured for a custom splash screen.</li>
<li><strong>✅ PASSED:</strong> Sets an address-bar theme color.</li>
</ul>
